import { IResolvers } from 'graphql-tools';
import GraphQLJSON, { GraphQLJSONObject } from 'graphql-type-json';
import pLimit from 'p-limit';
import * as _ from 'lodash';
import { GraphQLResolveInfo } from 'graphql';
import { createSchemaConfig } from '../graphql-service';
import { applyResourceGroupUpdates, ResourceGroup } from '../resource-repository';
import { validateResourceGroupOrThrow } from '../validation';
import { transformResourceGroup as applyPluginForResourceGroup } from '../plugins';
import PolicyAttachmentsGenerator from './policy-attachments-generator';
import resourceRepository from './repository';
import {
  BasePolicyInput,
  PolicyInput,
  ResourceGroupInput,
  SchemaInput,
  UpstreamClientCredentialsInput,
  UpstreamInput,
} from './types';

async function fetchAndValidate(
  updates: Partial<ResourceGroup>,
  policyAttachments: PolicyAttachmentsGenerator
): Promise<{ registryRg: ResourceGroup; gatewayRg: ResourceGroup }> {
  const { resourceGroup } = await resourceRepository.fetchLatest();
  const existingPolicies = _.cloneDeep(resourceGroup.policies);

  const newRg = applyResourceGroupUpdates(resourceGroup, updates);
  const registryRg = _.cloneDeep(newRg);

  const gatewayRg = await applyPluginForResourceGroup(newRg);
  validateResourceGroupOrThrow(gatewayRg);
  await createSchemaConfig(gatewayRg);

  // Policy definitions generated by plugins will always be re-generated here. This is probably
  // better than reading the previous gateway resource group just for this comparison
  const policiesDiff = _.differenceWith(gatewayRg.policies, existingPolicies, _.isEqual);
  await policyAttachments.generate(policiesDiff);

  return { gatewayRg, registryRg };
}

async function handleResourceGroupRequest(
  _: unknown,
  args: { input: ResourceGroupInput },
  _context: unknown,
  info: GraphQLResolveInfo
) {
  return singleton(async () => {
    const policyAttachments = new PolicyAttachmentsGenerator();

    try {
      const { gatewayRg, registryRg } = await fetchAndValidate(args.input, policyAttachments);
      if (info.operation.operation === 'mutation') {
        await policyAttachments.writeToRepo();
        await Promise.all([
          resourceRepository.update(registryRg, { registry: true }),
          resourceRepository.update(gatewayRg),
        ]);
      }
    } finally {
      await policyAttachments.cleanup();
    }

    return { success: true };
  });
}

const singleton = pLimit(1);

const resolvers: IResolvers = {
  JSON: GraphQLJSON,
  JSONObject: GraphQLJSONObject,
  Query: {
    validateResourceGroup: handleResourceGroupRequest,

    validateSchemas: (_, args: { input: SchemaInput[] }, _context: unknown, info: GraphQLResolveInfo) =>
      handleResourceGroupRequest(_, { input: { schemas: args.input } }, _context, info),

    validateUpstreams: (_, args: { input: UpstreamInput[] }, _context: unknown, info: GraphQLResolveInfo) =>
      handleResourceGroupRequest(_, { input: { upstreams: args.input } }, _context, info),

    validateUpstreamClientCredentials: (
      _,
      args: { input: UpstreamClientCredentialsInput[] },
      _context: unknown,
      info: GraphQLResolveInfo
    ) => handleResourceGroupRequest(_, { input: { upstreamClientCredentials: args.input } }, _context, info),

    validatePolicies: (_, args: { input: PolicyInput[] }, _context: unknown, info: GraphQLResolveInfo) =>
      handleResourceGroupRequest(_, { input: { policies: args.input } }, _context, info),

    validateBasePolicy: (_, args: { input: BasePolicyInput }, _context: unknown, info: GraphQLResolveInfo) =>
      handleResourceGroupRequest(_, { input: { basePolicy: args.input } }, _context, info),
  },
  Mutation: {
    updateResourceGroup: handleResourceGroupRequest,
    updateSchemas: (_, args: { input: SchemaInput[] }, _context: unknown, info: GraphQLResolveInfo) =>
      handleResourceGroupRequest(_, { input: { schemas: args.input } }, _context, info),

    updateUpstreams: (_, args: { input: UpstreamInput[] }, _context: unknown, info: GraphQLResolveInfo) =>
      handleResourceGroupRequest(_, { input: { upstreams: args.input } }, _context, info),

    updateUpstreamClientCredentials: (
      _: unknown,
      args: { input: UpstreamClientCredentialsInput[] },
      _context: unknown,
      info: GraphQLResolveInfo
    ) => handleResourceGroupRequest(_, { input: { upstreamClientCredentials: args.input } }, _context, info),

    updatePolicies: (_, args: { input: PolicyInput[] }, _context: unknown, info: GraphQLResolveInfo) =>
      handleResourceGroupRequest(_, { input: { policies: args.input } }, _context, info),

    updateBasePolicy: (_, args: { input: BasePolicyInput }, _context: unknown, info: GraphQLResolveInfo) =>
      handleResourceGroupRequest(_, { input: { basePolicy: args.input } }, _context, info),
  },
};

export default resolvers;
